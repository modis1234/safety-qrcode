{"ast":null,"code":"export function createAsyncDispatcher(type, promiseFn) {\n  const SUCCESS = `${type}/SUCCESS`;\n  const ERROR = `${type}/ERROR`;\n  console.log(type);\n\n  async function actionHandler(dispatch, ...rest) {\n    dispatch({\n      type\n    });\n\n    try {\n      const data = await promiseFn(...rest);\n      dispatch({\n        type: SUCCESS,\n        data\n      });\n    } catch (e) {\n      dispatch({\n        type: ERROR,\n        error: e\n      });\n    }\n  }\n\n  return actionHandler;\n}\nexport const initialAsyncState = {\n  loading: false,\n  data: null,\n  error: null\n}; // 로딩중일 때 바뀔 상태 객체\n\nconst loadingState = {\n  loading: true,\n  data: null,\n  error: null\n}; // 성공했을 때의 상태 만들어주는 함수\n\nconst success = data => ({\n  loading: false,\n  data,\n  error: null\n}); // 실패했을 때의 상태 만들어주는 함수\n\n\nconst error = error => ({\n  loading: false,\n  data: null,\n  error: error\n}); // 세가지 액션을 처리하는 리듀서를 만들어줍니다\n// type 은 액션 타입, key 는 리듀서서 사용할 필드 이름입니다 (예: user, users)\n\n\nexport function createAsyncHandler(type, key) {\n  // 성공, 실패에 대한 액션 타입 문자열을 준비합니다.\n  const SUCCESS = `${type}/SUCCESS`;\n  const ERROR = `${type}/ERROR`;\n  const ACTION = `${type}/FIND`; // 함수를 새로 만들어서\n\n  function handler(state, action) {\n    switch (action.type) {\n      case ACTION:\n        return { ...state,\n          [key]: loadingState\n        };\n\n      case SUCCESS:\n        return { ...state,\n          [key]: success(action.data)\n        };\n\n      case ERROR:\n        return { ...state,\n          [key]: error(action.error)\n        };\n\n      default:\n        return state;\n    }\n  } // 반환합니다\n\n\n  return handler;\n}","map":{"version":3,"sources":["D:/dev/safety-qrcode/src/uitils/asyncActionUtils.js"],"names":["createAsyncDispatcher","type","promiseFn","SUCCESS","ERROR","console","log","actionHandler","dispatch","rest","data","e","error","initialAsyncState","loading","loadingState","success","createAsyncHandler","key","ACTION","handler","state","action"],"mappings":"AAAA,OAAO,SAASA,qBAAT,CAA+BC,IAA/B,EAAqCC,SAArC,EAAgD;AACrD,QAAMC,OAAO,GAAI,GAAEF,IAAK,UAAxB;AACA,QAAMG,KAAK,GAAI,GAAEH,IAAK,QAAtB;AAGAI,EAAAA,OAAO,CAACC,GAAR,CAAYL,IAAZ;;AAEA,iBAAeM,aAAf,CAA6BC,QAA7B,EAAuC,GAAGC,IAA1C,EAAgD;AAC9CD,IAAAA,QAAQ,CAAC;AAAEP,MAAAA;AAAF,KAAD,CAAR;;AACA,QAAI;AACF,YAAMS,IAAI,GAAG,MAAMR,SAAS,CAAC,GAAGO,IAAJ,CAA5B;AACAD,MAAAA,QAAQ,CAAC;AAAEP,QAAAA,IAAI,EAAEE,OAAR;AAAiBO,QAAAA;AAAjB,OAAD,CAAR;AACD,KAHD,CAGE,OAAOC,CAAP,EAAU;AACVH,MAAAA,QAAQ,CAAC;AAAEP,QAAAA,IAAI,EAAEG,KAAR;AAAeQ,QAAAA,KAAK,EAAED;AAAtB,OAAD,CAAR;AACD;AACF;;AAED,SAAOJ,aAAP;AACD;AAED,OAAO,MAAMM,iBAAiB,GAAG;AAC/BC,EAAAA,OAAO,EAAE,KADsB;AAE/BJ,EAAAA,IAAI,EAAE,IAFyB;AAG/BE,EAAAA,KAAK,EAAE;AAHwB,CAA1B,C,CAMP;;AACA,MAAMG,YAAY,GAAG;AACnBD,EAAAA,OAAO,EAAE,IADU;AAEnBJ,EAAAA,IAAI,EAAE,IAFa;AAGnBE,EAAAA,KAAK,EAAE;AAHY,CAArB,C,CAMA;;AACA,MAAMI,OAAO,GAAIN,IAAD,KAAW;AACzBI,EAAAA,OAAO,EAAE,KADgB;AAEzBJ,EAAAA,IAFyB;AAGzBE,EAAAA,KAAK,EAAE;AAHkB,CAAX,CAAhB,C,CAMA;;;AACA,MAAMA,KAAK,GAAIA,KAAD,KAAY;AACxBE,EAAAA,OAAO,EAAE,KADe;AAExBJ,EAAAA,IAAI,EAAE,IAFkB;AAGxBE,EAAAA,KAAK,EAAEA;AAHiB,CAAZ,CAAd,C,CAMA;AACA;;;AACA,OAAO,SAASK,kBAAT,CAA4BhB,IAA5B,EAAkCiB,GAAlC,EAAuC;AAC5C;AACA,QAAMf,OAAO,GAAI,GAAEF,IAAK,UAAxB;AACA,QAAMG,KAAK,GAAI,GAAEH,IAAK,QAAtB;AAEA,QAAMkB,MAAM,GAAI,GAAElB,IAAK,OAAvB,CAL4C,CAO5C;;AACA,WAASmB,OAAT,CAAiBC,KAAjB,EAAwBC,MAAxB,EAAgC;AAC9B,YAAQA,MAAM,CAACrB,IAAf;AACE,WAAKkB,MAAL;AACE,eAAO,EACL,GAAGE,KADE;AAEL,WAACH,GAAD,GAAOH;AAFF,SAAP;;AAIF,WAAKZ,OAAL;AACE,eAAO,EACL,GAAGkB,KADE;AAEL,WAACH,GAAD,GAAOF,OAAO,CAACM,MAAM,CAACZ,IAAR;AAFT,SAAP;;AAIF,WAAKN,KAAL;AACE,eAAO,EACL,GAAGiB,KADE;AAEL,WAACH,GAAD,GAAON,KAAK,CAACU,MAAM,CAACV,KAAR;AAFP,SAAP;;AAIF;AACE,eAAOS,KAAP;AAjBJ;AAmBD,GA5B2C,CA8B5C;;;AACA,SAAOD,OAAP;AACD","sourcesContent":["export function createAsyncDispatcher(type, promiseFn) {\r\n  const SUCCESS = `${type}/SUCCESS`;\r\n  const ERROR = `${type}/ERROR`;\r\n\r\n\r\n  console.log(type)\r\n\r\n  async function actionHandler(dispatch, ...rest) {\r\n    dispatch({ type });\r\n    try {\r\n      const data = await promiseFn(...rest);\r\n      dispatch({ type: SUCCESS, data });\r\n    } catch (e) {\r\n      dispatch({ type: ERROR, error: e });\r\n    }\r\n  }\r\n\r\n  return actionHandler;\r\n}\r\n\r\nexport const initialAsyncState = {\r\n  loading: false,\r\n  data: null,\r\n  error: null,\r\n};\r\n\r\n// 로딩중일 때 바뀔 상태 객체\r\nconst loadingState = {\r\n  loading: true,\r\n  data: null,\r\n  error: null,\r\n};\r\n\r\n// 성공했을 때의 상태 만들어주는 함수\r\nconst success = (data) => ({\r\n  loading: false,\r\n  data,\r\n  error: null,\r\n});\r\n\r\n// 실패했을 때의 상태 만들어주는 함수\r\nconst error = (error) => ({\r\n  loading: false,\r\n  data: null,\r\n  error: error,\r\n});\r\n\r\n// 세가지 액션을 처리하는 리듀서를 만들어줍니다\r\n// type 은 액션 타입, key 는 리듀서서 사용할 필드 이름입니다 (예: user, users)\r\nexport function createAsyncHandler(type, key) {\r\n  // 성공, 실패에 대한 액션 타입 문자열을 준비합니다.\r\n  const SUCCESS = `${type}/SUCCESS`;\r\n  const ERROR = `${type}/ERROR`;\r\n\r\n  const ACTION = `${type}/FIND`;\r\n  \r\n  // 함수를 새로 만들어서\r\n  function handler(state, action) {\r\n    switch (action.type) {\r\n      case ACTION:\r\n        return {\r\n          ...state,\r\n          [key]: loadingState,\r\n        };\r\n      case SUCCESS:\r\n        return {\r\n          ...state,\r\n          [key]: success(action.data),\r\n        };\r\n      case ERROR:\r\n        return {\r\n          ...state,\r\n          [key]: error(action.error),\r\n        };\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  // 반환합니다\r\n  return handler;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}